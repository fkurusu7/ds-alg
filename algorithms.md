# ALGORITHMS

## TOP 10

1. TWO-POINTERS
2. SLIDING WINDOW
3. DYNAMIC PROGRAMMING
4. RECURSION
5. BINARY SEARCH ==> Runtime O(log(n))
   Use to find the position of an specific element
   in a Sorted List.
6. GREEDY.
   when not: Not used for efficiency
   Use when a problem is too complex
7. BACKTRACKING
8. BREADTH-FIRST SEARCH aka DFS - [trees & graphs]
   Looks at every node at one level before continuing further down.
   O(V + E)
   V: vertices/nodes
   E: edges/branches
9. DEPTH-FIRST SEARCH aka BFS - [trees & graphs]
   Start at the root node and go as far down one branch as possible all the way until the end. Once the deepest point is hit (DEPTH part), come back to unvisited branch and go down that one, this is called Backtracking.
   O(V + E)
   V: vertices/nodes
   E: edges/branches
10. INSERTION SORT  
    O(n log(n))
    Uses: best when lists are partially sorted, or small
11. MERGE SORT - Divide & conquer (divide the problem into smaller problems)
    O(n). worse case O(n\*\*2)
    Uses: best when lists are unsorted, or large

## TOP 20

1. TWO-POINTERS
2. SLIDING WINDOW
3. DYNAMIC PROGRAMMING
4. RECURSION
5. BINARY SEARCH
6. GREEDY
7. BREADTH-FIRST
8. DEPTH-FIRST
9. MERGE SORT
10. INSERTION SORT
11. QUICK SORT - divide and conquer, recursive
    O(n log(n)). worse case O(n\*\*2)
    FASTEST
12. ... DJIKSTRA
